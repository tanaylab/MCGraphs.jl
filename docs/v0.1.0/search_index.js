var documenterSearchIndex = {"docs":
[{"location":"validations.html#Validations","page":"Validations","title":"Validations","text":"","category":"section"},{"location":"validations.html","page":"Validations","title":"Validations","text":"MCGraphs.Validations\nMCGraphs.Validations.ObjectWithValidation\nMCGraphs.Validations.validate_object\nMCGraphs.Validations.assert_valid_object","category":"page"},{"location":"validations.html#MCGraphs.Validations","page":"Validations","title":"MCGraphs.Validations","text":"Validate user input.\n\nRendering graphs requires two objects: data and configuration. Both objects need to be internally consistent. This is especially relevant for the graph configuration. When creating UI for filling in these objects, we can in general easily validate each field on its own (e.g., ensure that a \"color\" field contains a valid color name). To ensure the overall object is consistent, we provide overall-type-specific validation functions that can be invoked by the UI to inform the user if the combination of (individually valid) field values is not valid for some reason.\n\n\n\n\n\n","category":"module"},{"location":"validations.html#MCGraphs.Validations.ObjectWithValidation","page":"Validations","title":"MCGraphs.Validations.ObjectWithValidation","text":"A common type for objects that support validation, that is, that one can invoke validate_object on.\n\n\n\n\n\n","category":"type"},{"location":"validations.html#MCGraphs.Validations.validate_object","page":"Validations","title":"MCGraphs.Validations.validate_object","text":"validate_object(object::ObjectWithValidation)::Maybe{AbstractString}\n\nValidate all field values of an object are compatible with each other, assuming each one is valid on its own. Returns nothing for a valid object and an error message if something is wrong. By default, this returns nothing.\n\nThis can be used by GUI widgets to validate the object as a whole (as opposed to validating each field based on its type).\n\n\n\n\n\n","category":"function"},{"location":"validations.html#MCGraphs.Validations.assert_valid_object","page":"Validations","title":"MCGraphs.Validations.assert_valid_object","text":"assert_valid_object(object_with_validation::ObjectWithValidation)::Maybe{AbstractString}\n\nThis will @assert that the object_with_validation is valid (that is, validate_object will return nothing for it). This is used in the back-end (graph rendering) code. It is recommended that the front-end (UI) code will invoke validate_object and ensure the user fixes problems before invoking the back-end code.\n\n\n\n\n\n","category":"function"},{"location":"validations.html#Index","page":"Validations","title":"Index","text":"","category":"section"},{"location":"validations.html","page":"Validations","title":"Validations","text":"Pages = [\"validations.md\"]","category":"page"},{"location":"index.html#MCGraphs","page":"MCGraphs","title":"MCGraphs","text":"","category":"section"},{"location":"index.html","page":"MCGraphs","title":"MCGraphs","text":"MCGraphs.MCGraphs","category":"page"},{"location":"index.html#MCGraphs.MCGraphs","page":"MCGraphs","title":"MCGraphs.MCGraphs","text":"Generate graphs for visualizing scRNA-seq metacells data in a Daf data set.\n\nThe goals of this are:\n\nProvide a specific set of graphs allowing for investigation and visualization of the metacells data.\nGenerate static PNG and/or SVG files (for publishing).\nGenerate interactive graphs in Jupyter notebook, both from Python and from R (for exploration).\nProvide guided UI in Jupyter notebook for accessing and customizing the graphs, as well as generating standard dashboards of related graphs.\nBe reasonably efficient when the data is large.\n\nThe overall architecture of the solution is based on the following layered implementation:\n\nJulia code:\n\nValidations contains functions for validating user input which can be invoked by the UI to ensure valid inputs.\nRenderers contains functions that actually render graphs, given the graph data and configuration. Each basic graph type has its own specification for the data and for the configuration. For example, a scatter plot data contains x coordinates, y coordinates, and colors, while the configuration controls the graph size, point shape and size, axis and graph titles, etc. We render most graphs using Plotly, but use ClusterGrammer for heatmaps.\nExtractors contains functions that extract graph data from a Daf data set. For example, a gene-gene plot will extract the expression of two genes in all metacells as the x and y coordinates, colored according to the type of the metacells.\nPlotters contains functions that combine extraction and rendering, that is, will render a graph given a Daf data set and a graph configuration. Each plot can specify different defaults for the graph configuration. For example, the default titles of a gene-gene plot would be different from the default titles of a differential expression plot, even though both will use the same scatter plot renderer.\n\nJupyter notebook code (need to be implemented in all Jupyter languages):\n\nControllers are Jupyter notebook UI elements for specifying which data to extract for a graph, or the configuration of a graph. For example, a data controller for a gene-gene plot will allow selecting the two genes, and a configuration controller for a scatter plot graph will allow specifying the point shape and size.\nWidgets combine multiple controllers to fully specify a graph to render. For example, a gene-gene graph widget will combine both the gene-gene plot data selection with the scatter plot graph configuration, using the specific defaults of the gene-gene graph.\nMenus allow selecting a single widget (for rendering a single graph) or several related widgets (for rendering a standard dashboard of graphs). For example, one entry in a menu could be \"gene-gene plot\" which generates a single graph while another might be \"metacells QC dashboard\" which generates multiple graphs visualizing various metacells QC measures. Menus are nested in a tree, such that invoking the root menu allows the user to interactively navigate to any of the provided plots and dashboards, without having to memorize the function names and configuration options.\n\nGenerating graphs is in general a read-only operation, allowing the analyst to explore the data. However, some work flows require creating and modifying data, for example, manual metacells type annotations. This is supported by dedicated controllers that write data back into the Daf data set, which is typically a chain consisting of a large read-only base data set combined with a small writeable data set containing the manually entered data. This allows reusing the same base data set with multiple alternative manual annotations.\n\nnote: Note\nWhile the overall architecture of the code here generalizes well, the functionality here is intentionally restricted to what we found useful for visualizing scRNA-seq metacells data in Daf data sets. Likewise, the amount of customization of the graphs is intentionally limited. The intent here is to make it as easy as possible for the analyst working in Jupyter notebook to explore the data, and generate graphs for academic papers, not to create yet another end-all-be-all graphs framework (of which there are too many already).\n\nThis is intentionally separated from the [Metacells.jl]((https://github.com/tanaylab/Metacells.jl) package itself, which is dedicated to computing the metacells.\n\n\n\n\n\n","category":"module"},{"location":"index.html#Index","page":"MCGraphs","title":"Index","text":"","category":"section"},{"location":"index.html","page":"MCGraphs","title":"MCGraphs","text":"","category":"page"}]
}
